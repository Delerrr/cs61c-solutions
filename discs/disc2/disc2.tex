\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{ulem}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{graphicx}
\begin{document}
\begin{enumerate}
	\item \begin{itemize}
		\item 1.1 True
		\item 1.2 ...
		\item 1.3 ...
		\item 1.4 ...
	\end{itemize}
	\item \begin{itemize}
		\item 2.1\\0xF9320904\\0xF93209AC\\0x2A
		\item 2.2\begin{enumerate}
			\item calculate the sum of \sout{all the elements}(\textcolor{red}{first n elements}) in arr
			\item sum = - (the number of zeros in arr)
			\item \sout{swap the value of x and y}(\textcolor{red}{Ultimately does not change the value of either x or y.})
			\item \verb|~(x ^ y)|\\also: \verb"x & y | ~ (x | y)"
			\\\textcolor{red}{x == y}
		\end{enumerate}
	\end{itemize}
	\item 3.1\begin{enumerate}
		\item \begin{verbatim}
			void swap(int *a, int *b) {
				int temp = *a;
				*a = *b;
				*b = temp;
			}
		\end{verbatim}
		\item \begin{verbatim}
			int mystrlen(char* a) {
				int ret = 0;
				while (*a != '\0') {
					ret++;
					a++;
				}
				return ret;
			}
		\end{verbatim}
	\end{enumerate}
	3.2\begin{enumerate}
		\item sizeof(summands) is incorrect, use an extra argument to pass the size of summands
		\item Can't understand the question.
		\item if the memory of dst is less than src, it will cause an error.\\multi suffix ++ (or prefix)should not be in one line, it's confusing and will easily cause trouble.
		\item line 5 is wrong: replaceptr is of type "char", not "char *"
	\end{enumerate}
	\item 4.1\begin{enumerate}
		\item static
		\item stack
		\item static(maybe)\textcolor{red}{Right!}
		\item static \textcolor{red}{(Code, static, or stack)}
		\item code
		\item heap
		\item static \textcolor{red}{or stack}
	\end{enumerate}
	4.2\begin{enumerate}
		\item \verb|int* arr = (int *) calloc (k, sizeof(int));|
		\item \verb|str = (char*) malloc ((p + 1) * sizeof(char))|
		\item \begin{verbatim}
			int **a = (int**) malloc (n * sizeof(int*));
			for (int i = 0; i < n; ++i) {
				a[i] = (int*) calloc (m, sizeof(int));
			}
		\end{verbatim}
	\end{enumerate}
	4.3\\\textcolor{red}{If the user input contains more than 63 characters, then the input will override other
		parts of the memory! }\\line 8 and line 9 both have problems.\\
		line 8: if the length of input is less than 11, important\_stuff will be assigned rubbish value\\
		line 9: $"\backslash0" is actually '\backslash0' and '\backslash0'$, not a character.\\
	4.4 \begin{verbatim}
		void prepend(struct ll_node** lst. int value) {
			struct ll_node* st = (struct ll_node*) malloc (sizeof(struct ll_node));
			st -> next = *lst;
			st -> value = value;
			*ll_node = st;
		}
	\end{verbatim}
	reason for double * :omitted\\
	4.5 \begin{verbatim}
		while (*lst != NULL) {
			struct ll_node* temp = (struct ll_node*) malloc (sizeof(struct ll_node));
			*lst = (*lst) -> next;
			free(temp);
		}
	\end{verbatim}
\end{enumerate}
\end{document}